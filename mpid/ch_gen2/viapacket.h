/*
 * Copyright (C) 1999-2001 The Regents of the University of California
 * (through E.O. Lawrence Berkeley National Laboratory), subject to
 * approval by the U.S. Department of Energy.
 *
 * Use of this software is under license. The license agreement is included
 * in the file MVICH_LICENSE.TXT.
 *
 * Developed at Berkeley Lab as part of MVICH.
 *
 * Authors: Bill Saphir      <wcsaphir@lbl.gov>
 *          Michael Welcome  <mlwelcome@lbl.gov>
 */

/* Copyright (c) 2002-2010, The Ohio State University. All rights
 * reserved.
 *
 * This file is part of the MVAPICH software package developed by the
 * team members of The Ohio State University's Network-Based Computing
 * Laboratory (NBCL), headed by Professor Dhabaleswar K. (DK) Panda.
 *
 * For detailed copyright and licensing information, please refer to the
 * copyright file COPYRIGHT_MVAPICH in the top level MPICH directory.
 *
 */

#ifndef _VIAPACKET_H
#define _VIAPACKET_H


/*
 * xxx Note that because of the include chain 
 * mpiimpl.h -> mpid.h -> req.h -> viapacket.h 
 * all MPI routines will be compiled with vipl.h. 
 * This is a lot of extra work given that only the
 * device needs this file, but I don't yet see an 
 * easy way to avoid it. On the plus side, it ensures that
 * everything is compiled with -D_REENTRANT. 
 */
#include "ibverbs_header.h"
#include "viaparam.h"

/* request ID is generated by sender and sent to receiver. Receiver
 * returns this ID in an ACK in order to allow sender to quickly retrieve
 * the request. Currently, this is just a pointer. In the future, if we
 * make use of immediate data with drma write. This might be to avoid
 * the extra RPUT_FINISH message, or it might be for unreliable
 * via. In the first case, the request type will be 32 bits. In the 
 * second case, it may be even less because we would have to fit
 * a sequence number into immediate data. 
 * The first case will fail on 64-bit machines; the second will
 * fail on all machines -- without a redefinition of request_id_t.
 */

typedef void *request_id_t;


typedef enum {
    /* first packet of an eager stream is distinguished from the rest. Both 
     * sender and receiver know how many packets total. After an EAGER_HEAD
     * packet, all subsequent packets will be EAGER_DATA until the transfer
     * is complete. 
     */

    VIADEV_PACKET_EAGER_START,
    VIADEV_PACKET_EAGER_NEXT,


    /* A rendezvous always starts off with START (we don't call it
     * RTS, since receiver may GET data).  Type of rendezvous
     * transaction is not specified explicitly as 1) the decision may
     * be made by receiver and 2) information on whether data is
     * pinned is implicit in buffer_address field, which is NULL if
     * data is not pinned. It is also NULL for length zero.  
     */

    VIADEV_PACKET_RENDEZVOUS_START,
    VIADEV_PACKET_RENDEZVOUS_START_RETRY,

    VIADEV_PACKET_RENDEZVOUS_REPLY,

    VIADEV_PACKET_R3_DATA,

    VIADEV_PACKET_R3_ACK,

    VIADEV_PACKET_RPUT_FINISH,

    VIADEV_PACKET_RGET_FINISH,

#ifdef VIADEV_SEND_CANCEL
    /* these packet types for attempting to cancel a send operations */

    /* REQUEST is a request to cancel the send from sender to receiver
     */
    VIADEV_SEND_CANCEL_REQUEST,
    /* REPLY is the message back from the receiver.  It will 
     * contain a message indicating ether the the send was
     * cancelled or that the send cannot be canceled
     */
    VIADEV_SEND_CANCEL_REPLY,
    /* In the case the send was canceled, the sender acknowledges
     * to the receiver that it will cease further sends of that message
     * and that the receiver may clean-up any partial messages
     */
    VIADEV_SEND_CANCEL_ACK,
#endif

#ifdef MEMORY_RELIABLE
    /* This packet type is used for acking the current data */
    VIADEV_PACKET_CRC_ACK,
#endif

    VIADEV_RDMA_ADDRESS,
    FAST_EAGER_CACHED,

    /* Used to implement a simple barrier sync on the VI network */
    VIADEV_PACKET_BARRIER,

    /* current use is only for piggybacking vbuf credit after
     * an eager send. Otherwise there the other side may become 
     * partially blocked and fall back to rendezvous. 
     */
    VIADEV_PACKET_NOOP,

    VIADEV_PACKET_EAGER_COALESCE,
#ifdef MCST_SUPPORT
    /* A rendezvous has to be cancelled if a coroot already received
     * UD pkt*/

    VIADEV_PACKET_RENDEZVOUS_CANCEL,

    VIADEV_PACKET_UD_MCST,
#endif
    VIADEV_PACKET_RGET,

    VIADEV_PACKET_RPUT
} viadev_packet_type;


/*
 * It would be nice if all packets had the same fixed-size header,
 * but we don't always have to send the same information. Collect
 * information needed by all packets in the front of the packet. 
 * MPICH puts together these structures using macros in a way
 * that seems ugly. Try a kinder gentler approach and see if it works. 
 */

typedef u_int16_t packet_sequence_t;

#if !defined(DISABLE_HEADER_CACHING) && defined(ADAPTIVE_RDMA_FAST_PATH)
#define FAST_EAGER_HEADER_SIZE 4
#endif

typedef struct {
    uint8_t type;              /* what type of packet is this? */
    uint8_t fast_eager_size;
    packet_sequence_t id;       /* sequence number of packet. Always checked for sanity
                                 * and later for reliability, except for noops */
    packet_sequence_t ack;      /* software ack */
    uint16_t vbuf_credit;      /* piggybacked vbuf credit   */
    uint16_t remote_credit;    /* our current credit count */
#ifdef ADAPTIVE_RDMA_FAST_PATH
    uint16_t rdma_credit;
#endif
    uint32_t src_rank;
#ifdef MEMORY_RELIABLE
    unsigned long crc32;
    uint32_t dma_len;
#endif
} viadev_packet_header;

typedef struct {
    int context;                /* context id -- identifies communicator */
    int tag;                    /* MPI message tag. */
    int data_length;            /* how many bytes in MPI message (not header).  */
    int src_lrank;              /* to help receiver */
} viadev_packet_envelope;


#if (defined(MCST_SUPPORT) || defined(ADAPTIVE_RDMA_FAST_PATH))
typedef struct {

    viadev_packet_header header;
    viadev_packet_envelope envelope;

#ifdef ADAPTIVE_RDMA_FAST_PATH
    void *RDMA_address;
    uint32_t RDMA_hndl;
#endif

#ifdef MCST_SUPPORT
    void *RDMA_ACK_address;
    uint32_t RDMA_ACK_hndl;
#endif
} viadev_packet_rdma_address;
#endif

/* 
 * eager first packet
 */

typedef struct {
    viadev_packet_header header;
    viadev_packet_envelope envelope;
    int bytes_in_this_packet;
} viadev_packet_eager_start;

/*
 * subsequent eager packets contain nothing but data
 */

typedef struct {
    viadev_packet_header header;
    int bytes_in_this_packet;
} viadev_packet_eager_next;

/* eager coalescing */

typedef struct {
    viadev_packet_header header;
    uint16_t pkt_count;
} viadev_packet_eager_coalesce;

typedef struct {
    uint8_t coalesce_type;
} viadev_packet_eager_coalesce_part;

typedef struct {
    uint8_t coalesce_type;
    viadev_packet_envelope envelope;
    int bytes_in_this_packet;
} viadev_packet_eager_coalesce_full;

enum {
    COALESCED_CACHED,
    COALESCED_NOT_CACHED
};

/* 
 * rendezvous init start
 */

typedef struct {
    viadev_packet_header header;
    viadev_packet_envelope envelope;
    void *buffer_address;
    uint32_t memhandle_rkey;
    int len;
    request_id_t sreq;
    int protocol;
} viadev_packet_rendezvous_start;

/*
 * single message to indicate the end of a long rendezvous transfer
 */
typedef struct {
    viadev_packet_header header;
    request_id_t rreq;          /* identifies receive handle */
} viadev_packet_rput_finish;

typedef struct {
    viadev_packet_header header;
    int ack_data;
} viadev_packet_r3_ack;

/*
 * single message to indicate the end of a long rendezvous transfer
 */
typedef struct {
    viadev_packet_header header;
    request_id_t sreq;          /* identifies send handle */
} viadev_packet_rget_finish;

/* Packet type to contain information about finish of
 * RDMA Read */
typedef struct {
    viadev_packet_header header;
    request_id_t rreq;          /* identifies receive request */
} viadev_packet_rget;

/* Packet type to contain information about rdma put */
typedef struct {
    viadev_packet_header header;
} viadev_packet_rput;



/*
 * rendezvous reply
 */

typedef struct {
    viadev_packet_header header;

    void *buffer_address;       /* address of pinned buffer on receiver. 
                                 * NULL if not pinned */
    uint32_t memhandle_rkey;   /* memory handle for buffer */

    request_id_t rreq;          /* identifies receive handle */
    request_id_t sreq;          /* identifies send handle (echoed) */

    int protocol;               /* explicitly specify protocol */
} viadev_packet_rendezvous_reply;

/*
 * r3 data 
 */

typedef struct {
    viadev_packet_header header;
    int bytes_in_this_packet;
    request_id_t rreq;
} viadev_packet_r3_data;

/*
 * Used to implement a simple barrier synchronization
 */
typedef struct {
    viadev_packet_header header;
    int barrier_id;
} viadev_packet_barrier;

/*
 * for noops 
 */

typedef struct {
    viadev_packet_header header;
#ifdef ADAPTIVE_RDMA_FAST_PATH
    uint32_t RDMA_hndl;
#endif
} viadev_packet_noop;


#ifdef MEMORY_RELIABLE
/* ack_type -> 0:Ack, ->1:Nack */
typedef struct {
    viadev_packet_header header;
    uint32_t ack_type;
    packet_sequence_t acked_seq_number;
} viadev_packet_crc_ack;
#endif

/*
 * note: there is no "packet" corresponding to rput data. 
 * all data goes directly into user buffer. The only control
 * data is the immediate data in the descsriptor. 
 */


/*
 * Macros to make life easier and consistent
 * 
 * note that PACKET_SET_HEADER has a side effect of 
 * transferring credit from the connection to the packet
 */

#ifndef MEMORY_RELIABLE 

#define PACKET_SET_HEADER(p, c, t) {                                \
    p->header.type = t;                                             \
    p->header.src_rank = viadev.me;                                 \
    if (VIADEV_LIKELY(t != VIADEV_PACKET_NOOP)) {                   \
        p->header.id   = c->next_packet_tosend++;                   \
        p->header.ack = 0;                                          \
    } else {                                                        \
        p->header.id = 0;                                           \
    }                                                               \
}

#else

#define PACKET_SET_HEADER(p, c, t) {                                \
    p->header.type = t;                                             \
    p->header.src_rank = viadev.me;                                 \
    if (t != VIADEV_PACKET_NOOP) {                                  \
        p->header.id   = c->next_packet_tosend++;                   \
        if (t != VIADEV_PACKET_CRC_ACK)                             \
            c->max_datapkt_seq = p->header.id;                      \
    } else                                                            \
        p->header.id = 0;                                           \
}

#endif

#ifdef ADAPTIVE_RDMA_FAST_PATH
#define PACKET_SET_CREDITS(p, c) {                                  \
    p->vbuf_credit = c->local_credit;                               \
    p->rdma_credit = c->rdma_credit;                                \
    c->rdma_credit = 0;                                             \
    c->local_credit = 0;                                            \
    p->remote_credit = c->remote_credit;                            \
}
#else

#define PACKET_SET_CREDITS(p, c) {                                  \
    p->vbuf_credit = c->local_credit;                               \
    c->local_credit = 0;                                            \
    p->remote_credit = c->remote_credit;                            \
}
#endif

#define PACKET_SET_ENVELOPE(p, ctx, tag, len, src) {                \
    p->envelope.context     = ctx;                                  \
    p->envelope.tag         = tag;                                  \
    p->envelope.data_length = len;                                  \
    p->envelope.src_lrank   = src;                                  \
}


typedef enum {
    /*    VIADEV_PROTOCOL_SHORT=1, */
    VIADEV_PROTOCOL_EAGER = 1,
    /* eager in several vbufs. short is special case */
    VIADEV_PROTOCOL_R3,
    /* rendezvous through receiver vbufs */
    VIADEV_PROTOCOL_RPUT,
    /* rendezvous with RDMA write from sender */
    VIADEV_PROTOCOL_RGET,
    /* rendezvous with RDMA read from receiver */
    VIADEV_PROTOCOL_RENDEZVOUS_UNSPECIFIED,
    /* need to figure out what to do */
    VIADEV_PROTOCOL_SMP_SHORT,
    /* roundez-zous smp */
    VIADEV_PROTOCOL_SMP_RNDV,
    VIADEV_PROTOCOL_EAGER_COALESCE,

#ifdef MCST_SUPPORT
    /* need to define protocol for UD */
    VIADEV_PROTOCOL_UD_MCST
#endif
} viadev_protocol_t;

#endif                          /* _VIAPACKET_H */
